---
layout: single
title: 백준 9465번 - 스티커
categories: algorithmProblems
tags: [algorithm, DP]
toc: true
toc_sticky: true
---

## 문제
[백준 9465번 문제](https://www.acmicpc.net/problem/9465) <br>
상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.

![9465_p_01.png](/assets/images/algorithm/9465_p_01.png)

모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.

위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

## 출력

각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.

## 예제 입력 1 복사

```
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80
```

## 예제 출력 1 복사

```
260
290
```

## 풀이
<div class="notice--primary" markdown="1">
**<u>2차원 배열로 경우를 나누어서 생각</u>** <br>
1. 첫번째 행에 있는 스티커를 뗄 경우 <br>
2. 두번째 행에 있는 스티커를 뗄 경우 <br>
3. 아무 스티커도 떼지 않을 경우
</div>

{% highlight cpp linenos%}
#include <bits/stdc++.h>
using namespace std;

/*
* d[j][i] : i번째에서 최댓값 
* j는 1->1행의 스티커를 골랐을 때, 
* 2->2행의 스티커를 골랐을 때, 
* 3->아무스티커도 고르지 않았을 때
*/
int d[4][100005];	
int arr[4][100005];

int main(void) 
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int t;
	cin >> t;
	while (t--)
	{
		int n;
		cin >> n;
		for (int i = 1; i <= 2; i++)
		{
			for (int j = 1; j <= n; j++)
				cin >> arr[i][j];
		}

		//초기값 정하기
		d[1][1] = arr[1][1];
		d[2][1] = arr[2][1];
		d[3][1] = 0;

		//점화식 채우기
		/*
		* d[1][i] : 윗줄의 스티커를 고를 경우 
		* -> 전 줄은 아무것도 고르지 않거나 / 전줄의 윗줄은 고르면 안됨 + 현재 스티커의 점수
		* 
		* d[2][i] : 아랫줄의 스티커를 고를 경우 
		* -> 전 줄은 아무것도 고르지 않거나 / 전줄의 아랫줄은 고르면 안됨 + 현재 스티커의 점수
		* 
		* d[3][i] : 아무 스티커도 고르지 않을 경우 
		* -> 전 줄은 상관없으므로 전 줄의 최댓값을 가져옴
		*/
		for (int i = 1; i <= n; i++)
		{
			d[1][i] = max(d[3][i - 1], d[2][i - 1]) + arr[1][i];
			d[2][i] = max(d[3][i - 1], d[1][i - 1]) + arr[2][i];
			d[3][i] = max({ d[3][i - 1], d[2][i - 1], d[1][i - 1] });
		}

		cout << max({ d[1][n], d[2][n], d[3][n] }) << "\n";
	}
}
{% endhighlight %}

## 다른풀이
<div class="notice--primary" markdown="1">
**<u>i-2 번째 스티커를 보는 방법</u>** <br>
dp[i][j] 일 때 i열째 j행의 스티커를 골랐을 때의 최댓값 (i는 n까지, j는 1행, 2행까지) <br>
i-2번째까지 보기 때문에 i에서 스티커를 골랐다고 해도 i+1에서 i번째에 아무것도 안고른 선택지를 선택 가능
</div>

{% highlight cpp linenos%}
#include <bits/stdc++.h>
using namespace std;

int main(void) 
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int tc;
	cin >> tc;

	while (tc--) 
	{
		int N;
		cin >> N;

		// N by 2 vector를 선언
		vector<vector<int>> arr(N, vector<int>(2));  
		vector<vector<int>> dp(N, vector<int>(2));

		for (int j = 0; j < 2; j++)
			for (int i = 0; i < N; i++)
				cin >> arr[i][j];

		for (int i = 0; i < N; i++) 
		{
			for (int j = 0; j < 2; j++) 
			{
				int v = 0;
				if (i > 1)	//i-2번째의 스티커 중 최대치
					v = max(dp[i - 2][0], dp[i - 2][1]);
				if (i > 0)	//i-1번째의 스티커 중 최대치
					v = max(v, dp[i - 1][1 - j]);
				dp[i][j] = v + arr[i][j];	//현재 스티커 점수 합산
			}
		}
		cout << max(dp[N - 1][0], dp[N - 1][1]) << '\n';
	}
}

/*
dp[i][j] : i번째 열까지에서 점수의 최댓값, 단 j행 i열의 스티커는 반드시 선택

가장 직전에 붙인 스티커가 i-2열의 스티커인 경우 : max(dp[i - 2][0], dp[i - 2][1]) + arr[i][j]
가장 직전에 붙인 스티커가 i-1열의 스티커인 경우 : dp[i-1][1-j] + arr[i][j]

마지막 열에 있는 스티커 중 어느 하나는 반드시 붙인게 최댓값이므로 max(dp[N - 1][0], dp[N - 1][1])을 계산하면 됨
*/
{% endhighlight %}
